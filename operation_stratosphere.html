<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operation Stratosphere</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Orbitron', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #00ff00;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 800px;
            height: 600px;
            border: 3px solid #00ff00;
            border-radius: 10px;
            background: #000015;
            box-shadow: 0 0 30px #00ff0050;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 7px;
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            z-index: 100;
            color: #00ff00;
            font-weight: 700;
            text-shadow: 0 0 10px #00ff00;
        }

        .title {
            position: absolute;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 900;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            z-index: 200;
            text-align: center;
            line-height: 1.2;
        }

        .subtitle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #00cccc;
            text-shadow: 0 0 15px #00cccc;
            z-index: 200;
            text-align: center;
            font-weight: 700;
            letter-spacing: 2px;
            margin-top: 10px;
        }

        .controls {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #ffffff;
            text-align: center;
            z-index: 200;
            line-height: 1.6;
            max-width: 600px;
            padding: 0 20px;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #ff0000;
            border-radius: 10px;
            text-align: center;
            z-index: 300;
            display: none;
        }

        .victory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #00ff00;
            border-radius: 10px;
            text-align: center;
            z-index: 300;
            display: none;
        }

        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.2s;
        }

        button:hover {
            background: #00cccc;
            box-shadow: 0 0 10px #00cccc;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="hud">
            <div>Temperature: <span id="temperature">+2.5°C</span></div>
            <div>Active Canisters: <span id="ammo">0</span></div>
            <div>Score: <span id="score">0</span></div>
        </div>

        <div class="title" id="titleScreen">
            OPERATION STRATOSPHERE
        </div>
        
        <div class="subtitle" id="titleSubtitle">
            CLIMATE DEFENSE ARCADE
        </div>
        
        <div class="controls" id="titleControls">
            Click moving canisters to deploy aerosol clouds and cool the planet!<br>
            <strong>SPACE</strong> to start • <strong>Click</strong> canisters to deploy them<br>
            <em>Survive as long as possible while keeping Earth cool!</em>
        </div>

        <div class="game-over" id="gameOver">
            <h2 style="color: #ff0000;">PLANET OVERHEATED!</h2>
            <p>The temperature rose too high!</p>
            <div style="background: rgba(50, 0, 0, 0.3); padding: 15px; margin: 15px 0; border: 1px solid #ff0000; border-radius: 5px; font-size: 12px; line-height: 1.4; text-align: left;">
                <strong>Consequences of Planetary Overheating:</strong><br>
                If Earth overheats beyond 3-4°C, we face mass displacement from sea level rise, uninhabitable heat zones, agricultural collapse, ecosystem breakdown, and potentially large regions becoming unsuitable for human civilization.
            </div>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button onclick="restartGame()">Try Again</button>
        </div>

        <div class="victory" id="victory">
            <h2 style="color: #00ff00;">CLIMATE STABILIZED!</h2>
            <p>You've successfully cooled the planet!</p>
            <div style="background: rgba(0, 50, 0, 0.3); padding: 15px; margin: 15px 0; border: 1px solid #00ff00; border-radius: 5px; font-size: 12px; line-height: 1.4; text-align: left;">
                <strong>About Stratospheric Aerosol Injection:</strong><br>
                Stratospheric aerosol injection releases reflective particles into the upper atmosphere to bounce sunlight back to space, potentially cooling Earth's surface by 1-2°C within years. While this could provide rapid climate relief, it carries major risks including disrupted weather patterns, ozone damage, and dangerous rebound warming if stopped while CO2 levels remain high.
            </div>
            <p>Final Score: <span id="victoryScore">0</span></p>
            <button onclick="restartGame()">Play Again</button>
        </div>
    </div>

    <script>
        class SoundSystem {
            constructor() {
                this.context = null;
                this.backgroundMusic = null;
                this.musicGain = null;
                this.init();
            }

            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.log("Audio not supported");
                }
            }

            startBackgroundMusic() {
                if (!this.context || this.backgroundMusic) return;
                
                this.musicGain = this.context.createGain();
                this.musicGain.connect(this.context.destination);
                this.musicGain.gain.setValueAtTime(0.05, this.context.currentTime);
                
                this.playBackgroundLoop();
            }

            playBackgroundLoop() {
                if (!this.context) return;
                
                const notes = [
                    {freq: 220, duration: 0.5}, {freq: 165, duration: 0.5},
                    {freq: 196, duration: 0.5}, {freq: 147, duration: 0.5},
                    {freq: 220, duration: 0.5}, {freq: 165, duration: 0.5},
                    {freq: 175, duration: 1.0}, {freq: 147, duration: 1.0}
                ];
                
                let time = 0;
                notes.forEach(note => {
                    setTimeout(() => {
                        if (this.musicGain) {
                            const osc = this.context.createOscillator();
                            const noteGain = this.context.createGain();
                            
                            osc.connect(noteGain);
                            noteGain.connect(this.musicGain);
                            
                            osc.frequency.setValueAtTime(note.freq, this.context.currentTime);
                            osc.type = 'sine';
                            
                            noteGain.gain.setValueAtTime(0.3, this.context.currentTime);
                            noteGain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + note.duration);
                            
                            osc.start(this.context.currentTime);
                            osc.stop(this.context.currentTime + note.duration);
                        }
                    }, time * 1000);
                    time += note.duration;
                });
                
                // Loop the music
                setTimeout(() => {
                    if (this.musicGain) this.playBackgroundLoop();
                }, time * 1000);
            }

            stopBackgroundMusic() {
                if (this.musicGain) {
                    this.musicGain.disconnect();
                    this.musicGain = null;
                    this.backgroundMusic = null;
                }
            }

            playTone(frequency, duration, type = 'sine', volume = 0.1) {
                if (!this.context) return;
                
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(volume, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
                
                oscillator.start(this.context.currentTime);
                oscillator.stop(this.context.currentTime + duration);
            }

            shoot() {
                this.playTone(400, 0.1, 'square', 0.1);
                setTimeout(() => this.playTone(300, 0.1, 'square', 0.08), 50);
            }

            hit() {
                this.playTone(800, 0.2, 'sawtooth', 0.15);
            }

            cooling() {
                this.playTone(200, 0.3, 'sine', 0.05);
                setTimeout(() => this.playTone(180, 0.3, 'sine', 0.05), 100);
            }

            warning() {
                this.playTone(1000, 0.1, 'square', 0.2);
                setTimeout(() => this.playTone(800, 0.1, 'square', 0.2), 150);
            }

            victory() {
                this.stopBackgroundMusic();
                const notes = [440, 523, 659, 880];
                notes.forEach((note, i) => {
                    setTimeout(() => this.playTone(note, 0.3, 'sine', 0.1), i * 200);
                });
            }

            gameOver() {
                this.stopBackgroundMusic();
                this.playTone(200, 0.5, 'sawtooth', 0.2);
                setTimeout(() => this.playTone(150, 0.5, 'sawtooth', 0.2), 200);
                setTimeout(() => this.playTone(100, 1, 'sawtooth', 0.15), 400);
            }

            explosion() {
                this.stopBackgroundMusic();
                
                // Create dramatic explosion sound with multiple layers
                // Deep rumble
                this.playTone(60, 1.5, 'sawtooth', 0.3);
                setTimeout(() => this.playTone(40, 1.0, 'sawtooth', 0.25), 100);
                
                // Mid explosion boom
                setTimeout(() => this.playTone(150, 0.8, 'square', 0.4), 200);
                setTimeout(() => this.playTone(120, 0.6, 'square', 0.35), 400);
                
                // High frequency crack/shatter
                setTimeout(() => this.playTone(800, 0.3, 'sawtooth', 0.2), 300);
                setTimeout(() => this.playTone(1200, 0.2, 'sawtooth', 0.15), 500);
                setTimeout(() => this.playTone(600, 0.4, 'sawtooth', 0.18), 700);
                
                // Final decay rumble
                setTimeout(() => this.playTone(80, 2.0, 'sawtooth', 0.2), 800);
                
                // Create white noise burst for explosion texture
                if (this.context) {
                    setTimeout(() => {
                        const bufferSize = this.context.sampleRate * 0.5; // 0.5 second burst
                        const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                        const output = buffer.getChannelData(0);
                        
                        for (let i = 0; i < bufferSize; i++) {
                            output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2); // Decaying noise
                        }
                        
                        const whiteNoise = this.context.createBufferSource();
                        const noiseGain = this.context.createGain();
                        
                        whiteNoise.buffer = buffer;
                        whiteNoise.connect(noiseGain);
                        noiseGain.connect(this.context.destination);
                        
                        noiseGain.gain.setValueAtTime(0.15, this.context.currentTime);
                        noiseGain.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.5);
                        
                        whiteNoise.start(this.context.currentTime);
                    }, 150);
                }
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.sound = new SoundSystem();
                
                this.gameState = 'menu'; // menu, playing, gameOver, victory
                this.temperature = 2.5;
                this.targetTemp = 0.5;
                this.activeCanisters = 0;
                this.score = 0;
                this.time = 0;
                this.gameSpeed = 1.0;
                
                this.ashClouds = [];
                this.heatSources = [];
                this.particles = [];
                this.movingCanisters = [];
                
                this.spawnTimer = 0;
                this.coolingEffect = 0;
                
                // Explosion and screen shake effects
                this.isExploding = false;
                this.explosionTime = 0;
                this.explosionParticles = [];
                this.screenShake = 0;
                this.shakeIntensity = 0;
                
                // Delta time tracking for consistent timing
                this.lastTime = 0;
                this.deltaTime = 0;
                this.realTime = 0; // Real time in seconds
                
                this.setupEventListeners();
                this.generateHeatSources();
                this.gameLoop();
            }

            setupEventListeners() {
                this.canvas.addEventListener('click', (e) => this.handleClick(e));
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
            }

            handleClick(e) {
                if (this.gameState !== 'playing') return;

                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * (this.canvas.width / rect.width);
                const y = (e.clientY - rect.top) * (this.canvas.height / rect.height);
                
                // Check if click hits any moving canister
                for (let i = this.movingCanisters.length - 1; i >= 0; i--) {
                    const canister = this.movingCanisters[i];
                    const dist = Math.sqrt((x - canister.x) ** 2 + (y - canister.y) ** 2);
                    
                    if (dist <= canister.radius) {
                        // Deploy aerosol cloud at canister location
                        this.deployAshCanister(canister.x, canister.y);
                        // Remove the clicked canister
                        this.movingCanisters.splice(i, 1);
                        this.activeCanisters--;
                        break;
                    }
                }
            }

            handleKeyDown(e) {
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (this.gameState === 'menu') {
                        this.startGame();
                    }
                }
            }

            startGame() {
                this.gameState = 'playing';
                this.temperature = 2.5;
                this.activeCanisters = 0;
                this.score = 0;
                this.time = 0;
                this.gameSpeed = 1.0;
                this.ashClouds = [];
                this.particles = [];
                this.movingCanisters = [];
                this.coolingEffect = 0;
                
                // Reset explosion effects
                this.isExploding = false;
                this.explosionTime = 0;
                this.explosionParticles = [];
                this.screenShake = 0;
                this.shakeIntensity = 0;
                
                // Reset delta time tracking
                this.lastTime = 0;
                this.deltaTime = 0;
                this.realTime = 0;
                
                document.getElementById('titleScreen').style.display = 'none';
                document.getElementById('titleSubtitle').style.display = 'none';
                document.getElementById('titleControls').style.display = 'none';
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('victory').style.display = 'none';
                
                this.targetTemp = 0.5; // Lower target for harder victory
                
                this.generateHeatSources();
                this.sound.startBackgroundMusic();
            }

            generateHeatSources() {
                this.heatSources = [];
                // Create various heat sources across the map
                for (let i = 0; i < 6; i++) { // Start with fewer heat sources
                    this.heatSources.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        intensity: 0.5 + Math.random() * 0.7, // Higher starting intensity
                        radius: 30 + Math.random() * 30,
                        type: Math.random() > 0.5 ? 'factory' : 'fire',
                        isNew: false
                    });
                }
            }

            deployAshCanister(x, y) {
                this.sound.shoot();
                
                // Create aerosol cloud
                this.createAshCloud(x, y);
            }

            createAshCloud(x, y) {
                const cloudSize = 100 + Math.random() * 50; // Larger clouds
                
                this.ashClouds.push({
                    x: x,
                    y: y,
                    radius: cloudSize,
                    opacity: 0.9,
                    life: 7.5, // 7.5 seconds lifetime for ash clouds
                    coolingPower: 0.025 // More powerful cooling
                });
                
                this.sound.hit();
                
                // Create particle effects
                for (let i = 0; i < 30; i++) { // More particles
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 60,
                        y: y + (Math.random() - 0.5) * 60,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        life: 1.3, // 1.3 seconds lifetime
                        size: 2 + Math.random() * 4,
                        color: `hsl(${30 + Math.random() * 30}, 50%, 60%)`
                    });
                }
            }

            update() {
                if (this.gameState !== 'playing') return;
                
                this.time++;
                this.realTime += this.deltaTime; // Track real time in seconds
                
                // Increase game speed over time (very slow pace) - now based on real time
                this.gameSpeed = 1.0 + (this.realTime / 300); // Speed increases every 5 minutes (300 seconds)
                
                // Spawn new moving canisters (reduced frequency) - now time-based
                this.spawnTimer += this.deltaTime;
                const spawnInterval = Math.max(2.5 - this.realTime / 120, 1.25); // 2.5 to 1.25 seconds
                if (this.spawnTimer >= spawnInterval) {
                    this.spawnMovingCanister();
                    this.spawnTimer = 0;
                }
                
                // Add new heat sources over time - now time-based
                if (Math.floor(this.realTime) % 30 === 0 && Math.floor(this.realTime) !== Math.floor(this.realTime - this.deltaTime)) {
                    this.addNewHeatSource();
                }
                
                // Intensify existing heat sources over time - now time-based
                if (Math.floor(this.realTime) % 15 === 0 && Math.floor(this.realTime) !== Math.floor(this.realTime - this.deltaTime)) {
                    this.intensifyHeatSources();
                }
                
                // Update moving canisters - now time-based
                this.movingCanisters = this.movingCanisters.filter(canister => {
                    // Movement now based on pixels per second instead of pixels per frame
                    canister.x += canister.vx * this.gameSpeed * this.deltaTime * 90; // *90 for 50% faster speed
                    canister.y += canister.vy * this.gameSpeed * this.deltaTime * 90;
                    
                    // Bounce off walls
                    if (canister.x <= canister.radius || canister.x >= this.canvas.width - canister.radius) {
                        canister.vx *= -1;
                    }
                    if (canister.y <= canister.radius || canister.y >= this.canvas.height - canister.radius) {
                        canister.vy *= -1;
                    }
                    
                    // Keep in bounds
                    canister.x = Math.max(canister.radius, Math.min(this.canvas.width - canister.radius, canister.x));
                    canister.y = Math.max(canister.radius, Math.min(this.canvas.height - canister.radius, canister.y));
                    
                    // Lifetime now in seconds instead of frames
                    canister.life -= this.deltaTime;
                    return canister.life > 0;
                });
                
                // Update ash clouds - now time-based
                this.ashClouds = this.ashClouds.filter(cloud => {
                    cloud.life -= this.deltaTime;
                    cloud.opacity = Math.max(0, cloud.life / 7.5); // 7.5 seconds total lifetime
                    return cloud.life > 0;
                });
                
                // Update particles - now time-based
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx * this.deltaTime * 60; // *60 to maintain similar speeds
                    particle.y += particle.vy * this.deltaTime * 60;
                    particle.vy += 6 * this.deltaTime; // gravity (6 pixels/sec²)
                    particle.life -= this.deltaTime;
                    return particle.life > 0;
                });
                
                // Calculate cooling effect (more powerful)
                this.coolingEffect = 0;
                this.ashClouds.forEach(cloud => {
                    this.coolingEffect += cloud.coolingPower * cloud.opacity;
                });
                
                // Calculate heating from unblocked sources (escalating heat)
                let heating = 0;
                this.heatSources.forEach(source => {
                    let blocked = false;
                    let blockingStrength = 0;
                    
                    this.ashClouds.forEach(cloud => {
                        const dist = Math.sqrt((cloud.x - source.x) ** 2 + (cloud.y - source.y) ** 2);
                        if (dist < cloud.radius + source.radius) {
                            blocked = true;
                            blockingStrength = Math.max(blockingStrength, cloud.opacity);
                        }
                    });
                    
                    // Heat sources can partially break through weak ash coverage
                    const effectiveIntensity = blocked ? 
                        source.intensity * (1 - blockingStrength * 0.7) : // Reduced blocking effectiveness
                        source.intensity;
                    
                    heating += effectiveIntensity * 0.00075; // Much slower base heating rate
                });
                
                // Additional background heating that increases over time - now time-based
                const backgroundHeating = (this.realTime / 1800) * 0.001; // Much slower increase rate
                heating += backgroundHeating;
                
                // Update temperature (more balanced)
                this.temperature += heating - this.coolingEffect;
                this.temperature = Math.max(0, this.temperature);
                
                // Play cooling sound effect
                if (this.coolingEffect > 0.01 && this.time % 60 === 0) {
                    this.sound.cooling();
                }
                
                // Update score based on cooling efficiency and time survived
                if (this.coolingEffect > 0) {
                    this.score += Math.floor(this.coolingEffect * 150); // Higher scoring
                }
                this.score += 2; // Higher time bonus
                
                // Check win/lose conditions (longer game)
                if (this.temperature >= 4.5) { // Higher temperature threshold
                    if (this.gameState === 'playing') {
                        // Start explosion sequence
                        this.isExploding = true;
                        this.explosionTime = 0;
                        this.screenShake = 1.0; // 1 second of screen shake
                        this.shakeIntensity = 15; // Intensity of shake
                        this.createExplosionParticles();
                        this.sound.explosion();
                        
                        // Delay showing game over screen to let explosion play
                        setTimeout(() => {
                            this.gameState = 'gameOver';
                            document.getElementById('gameOver').style.display = 'block';
                            document.getElementById('finalScore').textContent = this.score;
                        }, 2000); // 2 second delay
                    }
                } else if (this.temperature <= this.targetTemp && this.realTime > 60) { // 60 seconds real time requirement
                    this.gameState = 'victory';
                    this.sound.victory();
                    document.getElementById('victory').style.display = 'block';
                    document.getElementById('victoryScore').textContent = this.score;
                }
                
                // Warning sound when temperature is high - now time-based
                if (this.temperature > 4.0 && Math.floor(this.realTime * 2) % 4 === 0 && Math.floor(this.realTime * 2) !== Math.floor((this.realTime - this.deltaTime) * 2)) {
                    this.sound.warning();
                }
                
                // Update explosion effects - now time-based
                if (this.isExploding) {
                    this.explosionTime += this.deltaTime;
                    
                    // Update explosion particles
                    this.explosionParticles = this.explosionParticles.filter(particle => {
                        particle.x += particle.vx * this.deltaTime * 60; // *60 for similar speeds
                        particle.y += particle.vy * this.deltaTime * 60;
                        particle.vy += 12 * this.deltaTime; // gravity
                        particle.vx *= Math.pow(0.98, this.deltaTime * 60); // air resistance
                        particle.vy *= Math.pow(0.98, this.deltaTime * 60);
                        particle.rotation += particle.rotationSpeed * this.deltaTime;
                        particle.life -= this.deltaTime;
                        
                        return particle.life > 0;
                    });
                    
                    // Update screen shake
                    if (this.screenShake > 0) {
                        this.screenShake -= this.deltaTime;
                        this.shakeIntensity *= Math.pow(0.95, this.deltaTime * 60); // Gradually reduce shake intensity
                    }
                }
                
                this.updateHUD();
            }

            drawEarth() {
                const earthX = this.canvas.width / 2;
                const earthY = this.canvas.height / 2;
                const earthRadius = 280; // Much larger Earth!
                
                // If exploding, show dramatic explosion effects
                if (this.isExploding) {
                    // Draw explosion flash background
                    const flashIntensity = Math.max(0, 1 - this.explosionTime / 0.5); // 0.5 second flash
                    if (flashIntensity > 0) {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.8})`;
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                    
                    // Draw fragmenting Earth with cracks
                    const fragmentOffset = Math.min(this.explosionTime * 30, 50); // 30 pixels per second movement
                    const fragments = [
                        {angle: 0, offset: fragmentOffset},
                        {angle: Math.PI / 3, offset: fragmentOffset * 0.8},
                        {angle: Math.PI * 2/3, offset: fragmentOffset * 1.2},
                        {angle: Math.PI, offset: fragmentOffset * 0.9},
                        {angle: Math.PI * 4/3, offset: fragmentOffset * 1.1},
                        {angle: Math.PI * 5/3, offset: fragmentOffset * 0.7}
                    ];
                    
                    // Draw Earth fragments
                    fragments.forEach((fragment, i) => {
                        this.ctx.save();
                        this.ctx.translate(
                            earthX + Math.cos(fragment.angle) * fragment.offset,
                            earthY + Math.sin(fragment.angle) * fragment.offset
                        );
                        this.ctx.rotate(fragment.angle + this.explosionTime * 1.2); // 1.2 radians per second rotation
                        
                        // Draw fragment with fire glow
                        const fragmentRadius = earthRadius / 3;
                        const glowGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, fragmentRadius + 20);
                        glowGradient.addColorStop(0, 'rgba(255, 100, 0, 0.8)');
                        glowGradient.addColorStop(0.7, 'rgba(255, 50, 0, 0.4)');
                        glowGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        
                        this.ctx.fillStyle = glowGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, fragmentRadius + 20, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Draw the actual fragment
                        this.ctx.fillStyle = `rgb(${150 + Math.random() * 50}, ${50 + Math.random() * 30}, ${20 + Math.random() * 20})`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, fragmentRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.restore();
                    });
                    
                    // Draw central explosion core
                    const coreRadius = Math.max(0, earthRadius - this.explosionTime * 180); // 180 pixels per second shrinking
                    if (coreRadius > 0) {
                        const coreGradient = this.ctx.createRadialGradient(
                            earthX, earthY, 0,
                            earthX, earthY, coreRadius
                        );
                        coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                        coreGradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.9)');
                        coreGradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.7)');
                        coreGradient.addColorStop(1, 'rgba(255, 0, 0, 0.3)');
                        
                        this.ctx.fillStyle = coreGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(earthX, earthY, coreRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    return; // Skip normal Earth rendering
                }
                
                // Draw Earth's outer atmosphere glow (multiple layers for realism)
                for (let i = 0; i < 3; i++) {
                    const atmosphereGradient = this.ctx.createRadialGradient(
                        earthX, earthY, earthRadius + (i * 15),
                        earthX, earthY, earthRadius + (i * 25) + 30
                    );
                    const alpha = 0.15 - (i * 0.04);
                    atmosphereGradient.addColorStop(0, `rgba(135, 206, 250, ${alpha})`);
                    atmosphereGradient.addColorStop(0.5, `rgba(100, 150, 255, ${alpha * 0.7})`);
                    atmosphereGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
                    
                    this.ctx.fillStyle = atmosphereGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(earthX, earthY, earthRadius + (i * 25) + 30, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw Earth's ocean base with depth variations
                const oceanGradient = this.ctx.createRadialGradient(
                    earthX - 80, earthY - 80, 0,
                    earthX, earthY, earthRadius
                );
                
                // Temperature-based coloring with more realistic ranges
                let deepOcean, shallowOcean, landBase, landHigh, iceColor;
                if (this.gameState === 'playing') {
                    const heatLevel = Math.min(1, this.temperature / 4.5);
                    const baseBlue = Math.floor(220 - heatLevel * 80);
                    const baseGreen = Math.floor(160 - heatLevel * 60);
                    const baseRed = Math.floor(30 + heatLevel * 70);
                    
                    deepOcean = `rgb(${baseRed}, ${baseGreen - 40}, ${baseBlue})`;
                    shallowOcean = `rgb(${baseRed + 20}, ${baseGreen}, ${baseBlue - 20})`;
                    landBase = `rgb(${80 + heatLevel * 60}, ${120 - heatLevel * 40}, ${60 - heatLevel * 40})`;
                    landHigh = `rgb(${100 + heatLevel * 80}, ${100 - heatLevel * 30}, ${80 - heatLevel * 50})`;
                    iceColor = `rgb(${240 + heatLevel * 15}, ${250 - heatLevel * 30}, ${255 - heatLevel * 20})`;
                } else {
                    deepOcean = 'rgb(30, 120, 220)';
                    shallowOcean = 'rgb(50, 160, 200)';
                    landBase = 'rgb(80, 120, 60)';
                    landHigh = 'rgb(100, 100, 80)';
                    iceColor = 'rgb(240, 250, 255)';
                }
                
                oceanGradient.addColorStop(0, shallowOcean);
                oceanGradient.addColorStop(0.7, deepOcean);
                oceanGradient.addColorStop(1, 'rgba(20, 80, 150, 0.9)');
                
                this.ctx.fillStyle = oceanGradient;
                this.ctx.beginPath();
                this.ctx.arc(earthX, earthY, earthRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw more realistic continents with detailed shapes
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(earthX, earthY, earthRadius, 0, Math.PI * 2);
                this.ctx.clip();
                
                // North America - more detailed shape
                this.ctx.fillStyle = landBase;
                this.ctx.beginPath();
                this.ctx.moveTo(earthX - 140, earthY - 120);
                this.ctx.bezierCurveTo(earthX - 100, earthY - 140, earthX - 60, earthY - 130, earthX - 40, earthY - 100);
                this.ctx.bezierCurveTo(earthX - 30, earthY - 80, earthX - 50, earthY - 60, earthX - 70, earthY - 40);
                this.ctx.bezierCurveTo(earthX - 90, earthY - 20, earthX - 110, earthY + 10, earthX - 120, earthY + 40);
                this.ctx.bezierCurveTo(earthX - 130, earthY + 20, earthX - 150, earthY - 20, earthX - 160, earthY - 60);
                this.ctx.bezierCurveTo(earthX - 170, earthY - 90, earthX - 155, earthY - 110, earthX - 140, earthY - 120);
                this.ctx.fill();
                
                // Add Great Lakes
                this.ctx.fillStyle = deepOcean;
                this.ctx.beginPath();
                this.ctx.ellipse(earthX - 80, earthY - 50, 8, 5, 0, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.ellipse(earthX - 95, earthY - 45, 6, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // South America - more accurate shape
                this.ctx.fillStyle = landBase;
                this.ctx.beginPath();
                this.ctx.moveTo(earthX - 110, earthY + 50);
                this.ctx.bezierCurveTo(earthX - 100, earthY + 40, earthX - 85, earthY + 45, earthX - 80, earthY + 60);
                this.ctx.bezierCurveTo(earthX - 75, earthY + 90, earthX - 85, earthY + 120, earthX - 95, earthY + 150);
                this.ctx.bezierCurveTo(earthX - 105, earthY + 180, earthX - 115, earthY + 200, earthX - 110, earthY + 220);
                this.ctx.bezierCurveTo(earthX - 125, earthY + 200, earthX - 135, earthY + 160, earthX - 130, earthY + 120);
                this.ctx.bezierCurveTo(earthX - 135, earthY + 80, earthX - 125, earthY + 60, earthX - 110, earthY + 50);
                this.ctx.fill();
                
                // Africa - detailed shape
                this.ctx.fillStyle = landBase;
                this.ctx.beginPath();
                this.ctx.moveTo(earthX + 10, earthY - 80);
                this.ctx.bezierCurveTo(earthX + 30, earthY - 85, earthX + 50, earthY - 75, earthX + 60, earthY - 50);
                this.ctx.bezierCurveTo(earthX + 65, earthY - 20, earthX + 70, earthY + 10, earthX + 75, earthY + 40);
                this.ctx.bezierCurveTo(earthX + 80, earthY + 80, earthX + 75, earthY + 120, earthX + 65, earthY + 150);
                this.ctx.bezierCurveTo(earthX + 50, earthY + 170, earthX + 30, earthY + 175, earthX + 10, earthY + 165);
                this.ctx.bezierCurveTo(earthX - 5, earthY + 150, earthX - 10, earthY + 120, earthX - 5, earthY + 80);
                this.ctx.bezierCurveTo(earthX + 0, earthY + 40, earthX + 5, earthY, earthX + 8, earthY - 40);
                this.ctx.bezierCurveTo(earthX + 12, earthY - 60, earthX + 10, earthY - 80, earthX + 10, earthY - 80);
                this.ctx.fill();
                
                // Europe - smaller detailed shape
                this.ctx.fillStyle = landBase;
                this.ctx.beginPath();
                this.ctx.moveTo(earthX + 15, earthY - 90);
                this.ctx.bezierCurveTo(earthX + 25, earthY - 95, earthX + 40, earthY - 90, earthX + 50, earthY - 80);
                this.ctx.bezierCurveTo(earthX + 55, earthY - 70, earthX + 50, earthY - 60, earthX + 40, earthY - 55);
                this.ctx.bezierCurveTo(earthX + 25, earthY - 50, earthX + 15, earthY - 60, earthX + 10, earthY - 75);
                this.ctx.bezierCurveTo(earthX + 12, earthY - 85, earthX + 15, earthY - 90, earthX + 15, earthY - 90);
                this.ctx.fill();
                
                // Asia - large detailed continent
                this.ctx.fillStyle = landBase;
                this.ctx.beginPath();
                this.ctx.moveTo(earthX + 60, earthY - 80);
                this.ctx.bezierCurveTo(earthX + 100, earthY - 90, earthX + 140, earthY - 80, earthX + 170, earthY - 60);
                this.ctx.bezierCurveTo(earthX + 200, earthY - 40, earthX + 220, earthY - 10, earthX + 210, earthY + 20);
                this.ctx.bezierCurveTo(earthX + 200, earthY + 50, earthX + 180, earthY + 70, earthX + 150, earthY + 80);
                this.ctx.bezierCurveTo(earthX + 120, earthY + 85, earthX + 90, earthY + 75, earthX + 70, earthY + 50);
                this.ctx.bezierCurveTo(earthX + 65, earthY + 20, earthX + 68, earthY - 20, earthX + 75, earthY - 50);
                this.ctx.bezierCurveTo(earthX + 70, earthY - 70, earthX + 60, earthY - 80, earthX + 60, earthY - 80);
                this.ctx.fill();
                
                // Australia and Oceania
                this.ctx.fillStyle = landBase;
                this.ctx.beginPath();
                this.ctx.ellipse(earthX + 180, earthY + 120, 35, 25, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // New Zealand
                this.ctx.beginPath();
                this.ctx.ellipse(earthX + 220, earthY + 140, 8, 15, 0.3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add mountain ranges with highland coloring
                this.ctx.fillStyle = landHigh;
                
                // Rocky Mountains
                this.ctx.beginPath();
                this.ctx.ellipse(earthX - 100, earthY - 20, 8, 40, -0.2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Andes Mountains
                this.ctx.beginPath();
                this.ctx.ellipse(earthX - 115, earthY + 120, 6, 80, 0.1, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Himalayas
                this.ctx.beginPath();
                this.ctx.ellipse(earthX + 130, earthY - 20, 25, 8, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Alps
                this.ctx.beginPath();
                this.ctx.ellipse(earthX + 35, earthY - 70, 8, 4, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add polar ice caps
                this.ctx.fillStyle = iceColor;
                
                // North Pole
                const northCapGradient = this.ctx.createRadialGradient(
                    earthX, earthY - earthRadius + 40, 0,
                    earthX, earthY - earthRadius + 40, 60
                );
                northCapGradient.addColorStop(0, iceColor);
                northCapGradient.addColorStop(1, 'rgba(240, 250, 255, 0.3)');
                this.ctx.fillStyle = northCapGradient;
                this.ctx.beginPath();
                this.ctx.ellipse(earthX, earthY - earthRadius + 40, 80, 25, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // South Pole (Antarctica)
                const southCapGradient = this.ctx.createRadialGradient(
                    earthX, earthY + earthRadius - 50, 0,
                    earthX, earthY + earthRadius - 50, 70
                );
                southCapGradient.addColorStop(0, iceColor);
                southCapGradient.addColorStop(1, 'rgba(240, 250, 255, 0.2)');
                this.ctx.fillStyle = southCapGradient;
                this.ctx.beginPath();
                this.ctx.ellipse(earthX, earthY + earthRadius - 50, 90, 35, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.restore();
                
                // Add realistic cloud formations
                if (this.gameState === 'playing') {
                    const cloudTime = this.realTime * 0.3; // Real time-based cloud movement
                    
                    // Major cloud systems
                    const cloudSystems = [
                        {x: -100, y: -30, size: 40, density: 0.2}, // Pacific
                        {x: -60, y: 60, size: 35, density: 0.25}, // Amazon
                        {x: 40, y: 0, size: 30, density: 0.15}, // Africa
                        {x: 120, y: -40, size: 45, density: 0.18}, // Asia monsoon
                        {x: 150, y: 80, size: 25, density: 0.12} // Australia
                    ];
                    
                    cloudSystems.forEach((system, i) => {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${system.density})`;
                        const systemX = earthX + system.x + Math.cos(cloudTime + i) * 10;
                        const systemY = earthY + system.y + Math.sin(cloudTime * 0.7 + i) * 5;
                        
                        // Create multiple cloud layers
                        for (let j = 0; j < 8; j++) {
                            const angle = (j / 8) * Math.PI * 2 + cloudTime + i;
                            const cloudX = systemX + Math.cos(angle) * (system.size * 0.6);
                            const cloudY = systemY + Math.sin(angle) * (system.size * 0.3);
                            const cloudSize = 12 + Math.sin(cloudTime * 2 + i + j) * 6;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    });
                    
                    // Add storm systems
                    if (this.temperature > 3.0) {
                        this.ctx.fillStyle = 'rgba(200, 200, 200, 0.4)';
                        const stormX = earthX + Math.cos(cloudTime * 3) * 150;
                        const stormY = earthY + Math.sin(cloudTime * 2) * 100;
                        
                        for (let i = 0; i < 5; i++) {
                            const spiralAngle = (i / 5) * Math.PI * 2 + cloudTime * 4;
                            const spiralRadius = i * 8;
                            const sX = stormX + Math.cos(spiralAngle) * spiralRadius;
                            const sY = stormY + Math.sin(spiralAngle) * spiralRadius;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(sX, sY, 8, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
                
                // Draw Earth's terminator (day/night line) with smooth gradient
                const terminatorGradient = this.ctx.createLinearGradient(
                    earthX - earthRadius * 0.7, earthY,
                    earthX + earthRadius * 0.7, earthY
                );
                terminatorGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                terminatorGradient.addColorStop(0.3, 'rgba(0, 0, 0, 0.1)');
                terminatorGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.4)');
                terminatorGradient.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
                
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.arc(earthX, earthY, earthRadius, 0, Math.PI * 2);
                this.ctx.clip();
                
                this.ctx.fillStyle = terminatorGradient;
                this.ctx.fillRect(earthX - earthRadius, earthY - earthRadius, earthRadius * 2, earthRadius * 2);
                this.ctx.restore();
                
                // Add subtle city lights on night side
                if (this.gameState === 'playing') {
                    const cities = [
                        {x: earthX - 80, y: earthY - 30}, // New York area
                        {x: earthX - 120, y: earthY + 20}, // Los Angeles area
                        {x: earthX + 30, y: earthY - 60}, // London area
                        {x: earthX + 45, y: earthY - 40}, // Paris area
                        {x: earthX + 140, y: earthY - 10}, // Tokyo area
                        {x: earthX + 160, y: earthY + 20} // Sydney area
                    ];
                    
                    cities.forEach(city => {
                        // Only show lights on the night side
                        if (city.x > earthX) {
                            this.ctx.fillStyle = 'rgba(255, 255, 150, 0.6)';
                            this.ctx.beginPath();
                            this.ctx.arc(city.x, city.y, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            // Add glow
                            this.ctx.fillStyle = 'rgba(255, 255, 150, 0.2)';
                            this.ctx.beginPath();
                            this.ctx.arc(city.x, city.y, 5, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    });
                }
            }

            spawnMovingCanister() {
                if (this.activeCanisters >= 6) return; // Reduced max canisters
                
                const side = Math.floor(Math.random() * 4);
                let x, y, vx, vy;
                
                // Spawn from edges with much slower initial speeds for easier catching
                switch(side) {
                    case 0: // Top
                        x = Math.random() * this.canvas.width;
                        y = -25;
                        vx = (Math.random() - 0.5) * 1.5; // Reduced from 3 to 1.5
                        vy = 0.5 + Math.random() * 0.75; // Reduced from 1-2.5 to 0.5-1.25
                        break;
                    case 1: // Right
                        x = this.canvas.width + 25;
                        y = Math.random() * this.canvas.height;
                        vx = -(0.5 + Math.random() * 0.75); // Reduced from 1-2.5 to 0.5-1.25
                        vy = (Math.random() - 0.5) * 1.5; // Reduced from 3 to 1.5
                        break;
                    case 2: // Bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 25;
                        vx = (Math.random() - 0.5) * 1.5; // Reduced from 3 to 1.5
                        vy = -(0.5 + Math.random() * 0.75); // Reduced from 1-2.5 to 0.5-1.25
                        break;
                    case 3: // Left
                        x = -25;
                        y = Math.random() * this.canvas.height;
                        vx = 0.5 + Math.random() * 0.75; // Reduced from 1-2.5 to 0.5-1.25
                        vy = (Math.random() - 0.5) * 1.5; // Reduced from 3 to 1.5
                        break;
                }
                
                this.movingCanisters.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    radius: 25, // Much larger click targets for easier clicking
                    life: 30, // 30 seconds lifetime
                    pulse: 0
                });
                
                this.activeCanisters++;
            }

            addNewHeatSource() {
                this.heatSources.push({
                    x: Math.random() * this.canvas.width,
                    y: Math.random() * this.canvas.height,
                    intensity: 0.6 + Math.random() * 1.0, // Higher starting intensity
                    radius: 25 + Math.random() * 40,
                    type: Math.random() > 0.5 ? 'factory' : 'fire',
                    isNew: true // Mark as new for visual effect
                });
                
                // Play warning sound for new heat source
                this.sound.warning();
            }

            intensifyHeatSources() {
                this.heatSources.forEach(source => {
                    source.intensity = Math.min(2.0, source.intensity * 1.05); // 5% increase, much slower
                    source.radius = Math.min(90, source.radius * 1.025); // Much slower radius increase
                });
            }

            createExplosionParticles() {
                const earthX = this.canvas.width / 2;
                const earthY = this.canvas.height / 2;
                const earthRadius = 280;
                
                // Create massive explosion particle system
                for (let i = 0; i < 150; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 5 + Math.random() * 15;
                    const size = 8 + Math.random() * 20;
                    const distance = Math.random() * earthRadius * 0.8; // Start from within Earth
                    
                    const particleLife = 1.7 + Math.random() * 1.7; // 1.7-3.4 seconds
                    
                    this.explosionParticles.push({
                        x: earthX + Math.cos(angle) * distance,
                        y: earthY + Math.sin(angle) * distance,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: size,
                        life: particleLife,
                        maxLife: particleLife, // Same as initial life for proper alpha calculation
                        color: Math.random() > 0.6 ? 'fire' : Math.random() > 0.3 ? 'rock' : 'smoke',
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3
                    });
                }
            }

            updateHUD() {
                document.getElementById('temperature').textContent = `+${this.temperature.toFixed(1)}°C`;
                document.getElementById('temperature').style.color = 
                    this.temperature > 3.5 ? '#ff0000' : 
                    this.temperature > 2.5 ? '#ffaa00' : '#00ff00';
                
                document.getElementById('ammo').textContent = this.movingCanisters.length;
                document.getElementById('score').textContent = this.score;
            }

            draw() {
                // Apply screen shake if active
                let shakeOffsetX = 0;
                let shakeOffsetY = 0;
                if (this.screenShake > 0) {
                    shakeOffsetX = (Math.random() - 0.5) * this.shakeIntensity;
                    shakeOffsetY = (Math.random() - 0.5) * this.shakeIntensity;
                    this.ctx.save();
                    this.ctx.translate(shakeOffsetX, shakeOffsetY);
                }
                
                // Clear canvas with star field background
                this.ctx.fillStyle = '#000015';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw stars
                for (let i = 0; i < 100; i++) {
                    const x = (i * 7919) % this.canvas.width;
                    const y = (i * 4373) % this.canvas.height;
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${0.2 + Math.random() * 0.3})`;
                    this.ctx.fillRect(x, y, 1, 1);
                }
                
                // Draw Earth in background
                this.drawEarth();
                
                // Draw explosion particles
                if (this.isExploding) {
                    this.explosionParticles.forEach(particle => {
                        this.ctx.save();
                        this.ctx.translate(particle.x, particle.y);
                        this.ctx.rotate(particle.rotation);
                        
                        const alpha = particle.life / particle.maxLife;
                        let color;
                        
                        switch(particle.color) {
                            case 'fire':
                                color = `rgba(255, ${Math.floor(100 + alpha * 155)}, 0, ${alpha})`;
                                break;
                            case 'rock':
                                color = `rgba(${Math.floor(100 + alpha * 100)}, ${Math.floor(50 + alpha * 50)}, 20, ${alpha})`;
                                break;
                            case 'smoke':
                                color = `rgba(60, 60, 60, ${alpha * 0.7})`;
                                break;
                        }
                        
                        this.ctx.fillStyle = color;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.size * alpha, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Add glow for fire particles
                        if (particle.color === 'fire') {
                            this.ctx.fillStyle = `rgba(255, 200, 0, ${alpha * 0.3})`;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, particle.size * alpha * 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        this.ctx.restore();
                    });
                }
                
                if (this.gameState !== 'playing') {
                    // Restore screen shake transformation
                    if (this.screenShake > 0) {
                        this.ctx.restore();
                    }
                    return;
                }
                
                // Draw heat sources
                this.heatSources.forEach(source => {
                    // Check if blocked by ash clouds (with partial blocking)
                    let blocked = false;
                    let blockingStrength = 0;
                    this.ashClouds.forEach(cloud => {
                        const dist = Math.sqrt((cloud.x - source.x) ** 2 + (cloud.y - source.y) ** 2);
                        if (dist < cloud.radius + source.radius) {
                            blocked = true;
                            blockingStrength = Math.max(blockingStrength, cloud.opacity);
                        }
                    });
                    
                    // Calculate effective intensity (heat can partially break through)
                    const effectiveIntensity = blocked ? 
                        source.intensity * (1 - blockingStrength * 0.8) : 
                        source.intensity;
                    
                    // Draw heat waves with intensity-based coloring
                    const gradient = this.ctx.createRadialGradient(
                        source.x, source.y, 0,
                        source.x, source.y, source.radius
                    );
                    const heatColor = effectiveIntensity > 0.8 ? 255 : 
                                     effectiveIntensity > 0.5 ? 200 : 150;
                    gradient.addColorStop(0, `rgba(${heatColor}, ${100 - effectiveIntensity * 100}, 0, ${effectiveIntensity * 0.8})`);
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.fillRect(
                        source.x - source.radius,
                        source.y - source.radius,
                        source.radius * 2,
                        source.radius * 2
                    );
                    
                    // Draw source icon with intensity-based sizing
                    const iconSize = 6 + (source.intensity * 6);
                    this.ctx.fillStyle = effectiveIntensity < 0.2 ? '#666' : 
                                        effectiveIntensity < 0.5 ? '#ff6600' : '#ff0000';
                    
                    if (source.type === 'factory') {
                        this.ctx.fillRect(source.x - iconSize, source.y - iconSize, iconSize * 2, iconSize * 2);
                    } else {
                        this.ctx.beginPath();
                        this.ctx.arc(source.x, source.y, iconSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Flash effect for new heat sources
                    if (source.isNew) {
                        this.ctx.strokeStyle = '#ff0000';
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(source.x, source.y, source.radius + 10, 0, Math.PI * 2);
                        this.ctx.stroke();
                        
                        // Remove the new flag after a short time
                        setTimeout(() => { source.isNew = false; }, 2000);
                    }
                });
                
                // Draw ash clouds
                this.ashClouds.forEach(cloud => {
                    const gradient = this.ctx.createRadialGradient(
                        cloud.x, cloud.y, 0,
                        cloud.x, cloud.y, cloud.radius
                    );
                    gradient.addColorStop(0, `rgba(120, 120, 120, ${cloud.opacity * 0.7})`);
                    gradient.addColorStop(0.7, `rgba(80, 80, 80, ${cloud.opacity * 0.4})`);
                    gradient.addColorStop(1, 'rgba(60, 60, 60, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw moving canisters
                this.movingCanisters.forEach(canister => {
                    canister.pulse += 0.2;
                    const pulseSize = 2 + Math.sin(canister.pulse) * 3;
                    
                    // Outer glow
                    const gradient = this.ctx.createRadialGradient(
                        canister.x, canister.y, 0,
                        canister.x, canister.y, canister.radius + pulseSize
                    );
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(0, 255, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(canister.x, canister.y, canister.radius + pulseSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Inner canister
                    this.ctx.fillStyle = '#00ffff';
                    this.ctx.beginPath();
                    this.ctx.arc(canister.x, canister.y, canister.radius - 5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Center core
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(canister.x, canister.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Speed indicator arrows
                    const speed = Math.sqrt(canister.vx ** 2 + canister.vy ** 2) * this.gameSpeed;
                    this.ctx.strokeStyle = `rgba(255, 255, 0, ${Math.min(speed / 5, 1)})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(canister.x, canister.y);
                    this.ctx.lineTo(
                        canister.x + canister.vx * 10,
                        canister.y + canister.vy * 10
                    );
                    this.ctx.stroke();
                });
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Draw temperature indicator with warning effects
                const tempBar = this.canvas.width - 40;
                const tempHeight = 200;
                const tempY = 100;
                
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(tempBar, tempY, 20, tempHeight);
                
                const tempLevel = (this.temperature / 4.5) * tempHeight; // Updated for new max temp
                let tempColor = this.temperature > 4.0 ? '#ff0000' : 
                               this.temperature > 3.0 ? '#ffaa00' : '#00ff00';
                
                // Flashing effect when critically hot
                if (this.temperature > 4.0 && Math.floor(this.time / 10) % 2 === 0) {
                    tempColor = '#ffffff';
                }
                
                this.ctx.fillStyle = tempColor;
                this.ctx.fillRect(tempBar + 2, tempY + tempHeight - tempLevel, 16, tempLevel);
                
                // Background heating indicator (moved to bottom)
                const backgroundHeating = (this.realTime / 1800) * 0.001;
                if (backgroundHeating > 0.001) {
                    this.ctx.fillStyle = 'rgba(255, 80, 80, 0.6)';
                    this.ctx.fillRect(0, this.canvas.height - 35, this.canvas.width, 35);
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = 'bold 14px Orbitron';
                    this.ctx.textAlign = 'center';
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeText('⚠️ GLOBAL WARMING ACCELERATING! ⚠️', this.canvas.width / 2, this.canvas.height - 13);
                    this.ctx.fillText('⚠️ GLOBAL WARMING ACCELERATING! ⚠️', this.canvas.width / 2, this.canvas.height - 13);
                    this.ctx.textAlign = 'left'; // Reset text alignment
                }
                
                // Restore screen shake transformation
                if (this.screenShake > 0) {
                    this.ctx.restore();
                }
            }

            gameLoop() {
                const currentTime = performance.now();
                if (this.lastTime === 0) {
                    this.lastTime = currentTime;
                }
                
                this.deltaTime = (currentTime - this.lastTime) / 1000; // Convert to seconds
                this.lastTime = currentTime;
                
                // Cap delta time to prevent huge jumps (e.g., when tab is inactive)
                this.deltaTime = Math.min(this.deltaTime, 1/30); // Max 30 FPS equivalent
                
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        function restartGame() {
            game.gameState = 'menu';
            document.getElementById('titleScreen').style.display = 'block';
            document.getElementById('titleSubtitle').style.display = 'block';
            document.getElementById('titleControls').style.display = 'block';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('victory').style.display = 'none';
            game.sound.stopBackgroundMusic();
        }

        // Initialize game
        const game = new Game();
    </script>
</body>
</html>